const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('.')); // Serve static files from root

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'lotato-pro-super-secret-key-2024';

// Connexion MongoDB avec meilleure gestion d'erreurs
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/lotato';

console.log('üîß Initialisation de la connexion MongoDB...');
console.log('üì° MongoDB URI configur√©e:', MONGODB_URI ? 'OUI' : 'NON');

// Options de connexion MongoDB
const mongooseOptions = {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  serverSelectionTimeoutMS: 10000, // 10 secondes
  socketTimeoutMS: 45000, // 45 secondes
  maxPoolSize: 10, // Nombre maximum de connexions
  retryWrites: true,
  w: 'majority'
};

// Fonction pour connecter √† MongoDB
const connectWithRetry = async () => {
  try {
    await mongoose.connect(MONGODB_URI, mongooseOptions);
    console.log('‚úÖ Connect√© √† MongoDB avec succ√®s');
    console.log(`üìä Base de donn√©es: ${mongoose.connection.db.databaseName}`);
    console.log(`üåê Environnement: ${process.env.NODE_ENV || 'development'}`);
  } catch (err) {
    console.error('‚ùå √âchec de connexion √† MongoDB:', err.message);
    console.log('üîÑ Nouvelle tentative dans 5 secondes...');
    setTimeout(connectWithRetry, 5000);
  }
};

// Gestionnaires d'√©v√©nements MongoDB
mongoose.connection.on('connected', () => {
  console.log('üîó Mongoose connect√© √† MongoDB');
});

mongoose.connection.on('error', (err) => {
  console.error('‚ùå Erreur de connexion Mongoose:', err.message);
});

mongoose.connection.on('disconnected', () => {
  console.log('üîå Mongoose d√©connect√© de MongoDB');
});

// Initialiser la connexion
connectWithRetry();

// Sch√©mas et Mod√®les
const ticketSchema = new mongoose.Schema({
  ticketId: { type: String, required: true, unique: true },
  agentId: { type: String, required: true },
  agentName: { type: String, required: true },
  drawId: { type: String, required: true },
  drawName: { type: String, required: true },
  bets: [{
    game: String,
    number: String,
    cleanNumber: String,
    amount: Number,
    isAutoGenerated: Boolean,
    specialType: String,
    gain: { type: Number, default: 0 }
  }],
  total: { type: Number, required: true },
  checked: { type: Boolean, default: false },
  date: { type: Date, default: Date.now }
});

const winnerSchema = new mongoose.Schema({
  ticketId: { type: String, required: true },
  agentId: { type: String, required: true },
  agentName: { type: String, required: true },
  drawId: { type: String, required: true },
  drawName: { type: String, required: true },
  gameType: { type: String, required: true },
  winningNumber: { type: String, required: true },
  winningAmount: { type: Number, required: true },
  customerName: { type: String, default: '' },
  paid: { type: Boolean, default: false },
  date: { type: Date, default: Date.now }
});

const agentSchema = new mongoose.Schema({
  agentId: { type: String, required: true, unique: true },
  agentName: { type: String, required: true },
  password: { type: String, required: true, default: '123456' },
  role: { type: String, default: 'agent' },
  funds: { type: Number, default: 10000 },
  lotteryName: { type: String, default: 'LOTATO PRO' },
  lotteryLogo: { type: String, default: '' },
  lotteryAddress: { type: String, default: '' },
  lotteryPhone: { type: String, default: '' },
  isActive: { type: Boolean, default: true },
  supervisorId: { type: String, required: true },
  lastActivity: { type: Date, default: Date.now },
  online: { type: Boolean, default: false },
  location: { type: String, default: '' },
  createdAt: { type: Date, default: Date.now }
});

const supervisorSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true, default: '123456' },
  name: { type: String, required: true },
  role: { type: String, default: 'supervisor' },
  permissions: [String],
  maxDeleteTime: { type: Number, default: 10 }, // minutes
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now }
});

const ownerSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true, default: '123456' },
  name: { type: String, required: true },
  role: { type: String, default: 'owner' },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now })
});

const Ticket = mongoose.model('Ticket', ticketSchema);
const Winner = mongoose.model('Winner', winnerSchema);
const Agent = mongoose.model('Agent', agentSchema);
const Supervisor = mongoose.model('Supervisor', supervisorSchema);
const Owner = mongoose.model('Owner', ownerSchema);

// Middleware d'authentification
const authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Token otantifikasyon obligatwa'
      });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'Token pa valab'
    });
  }
};

// Middleware de v√©rification de r√¥le
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen otorizasyon pou aksyon sa a'
      });
    }
    next();
  };
};

// === ROUTES D'AUTHENTIFICATION ===

// 1. Connexion Agent
app.post('/api/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // Chercher l'agent par son agentId
    const agent = await Agent.findOne({ 
      agentId: username.toUpperCase(),
      isActive: true 
    });
    
    if (!agent) {
      return res.status(401).json({
        success: false,
        message: 'K√≤d ajan pa egziste'
      });
    }

    // Comparer les mots de passe (sans bcrypt)
    if (agent.password !== password) {
      return res.status(401).json({
        success: false,
        message: 'Modpas pa k√≤r√®k'
      });
    }

    // Mettre √† jour le statut en ligne
    agent.online = true;
    agent.lastActivity = new Date();
    await agent.save();

    // Cr√©er le token JWT
    const token = jwt.sign(
      {
        id: agent._id,
        agentId: agent.agentId,
        name: agent.agentName,
        role: 'agent'
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,
      message: 'Koneksyon reyisi',
      token: token,
      user: {
        id: agent._id,
        agentId: agent.agentId,
        name: agent.agentName,
        role: 'agent'
      }
    });
  } catch (error) {
    console.error('Erreur connexion agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® s√®v√® ent√®n'
    });
  }
});

// 2. Connexion Superviseur
app.post('/api/auth/supervisor-login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // Chercher le superviseur
    const supervisor = await Supervisor.findOne({ 
      username: username.toLowerCase(),
      isActive: true 
    });
    
    if (!supervisor) {
      return res.status(401).json({
        success: false,
        message: 'Superviz√® pa egziste'
      });
    }

    // Comparer les mots de passe (sans bcrypt)
    if (supervisor.password !== password) {
      return res.status(401).json({
        success: false,
        message: 'Modpas pa k√≤r√®k'
      });
    }

    // Cr√©er le token JWT
    const token = jwt.sign(
      {
        id: supervisor._id,
        username: supervisor.username,
        name: supervisor.name,
        role: 'supervisor',
        permissions: supervisor.permissions,
        maxDeleteTime: supervisor.maxDeleteTime
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,
      message: 'Koneksyon reyisi',
      token: token,
      user: {
        id: supervisor._id,
        username: supervisor.username,
        name: supervisor.name,
        role: 'supervisor',
        permissions: supervisor.permissions,
        maxDeleteTime: supervisor.maxDeleteTime
      }
    });
  } catch (error) {
    console.error('Erreur connexion superviseur:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® s√®v√® ent√®n'
    });
  }
});

// 3. Connexion Propri√©taire
app.post('/api/auth/owner-login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // Chercher le propri√©taire
    const owner = await Owner.findOne({ 
      username: username.toLowerCase(),
      isActive: true 
    });
    
    if (!owner) {
      return res.status(401).json({
        success: false,
        message: 'Pwopriyet√® pa egziste'
      });
    }

    // Comparer les mots de passe (sans bcrypt)
    if (owner.password !== password) {
      return res.status(401).json({
        success: false,
        message: 'Modpas pa k√≤r√®k'
      });
    }

    // Cr√©er le token JWT
    const token = jwt.sign(
      {
        id: owner._id,
        username: owner.username,
        name: owner.name,
        role: 'owner'
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,
      message: 'Koneksyon reyisi',
      token: token,
      user: {
        id: owner._id,
        username: owner.username,
        name: owner.name,
        role: 'owner'
      }
    });
  } catch (error) {
    console.error('Erreur connexion propri√©taire:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® s√®v√® ent√®n'
    });
  }
});

// 4. V√©rification de session
app.get('/api/auth/verify', authenticate, async (req, res) => {
  res.json({
    success: true,
    user: req.user
  });
});

// 5. D√©connexion
app.post('/api/auth/logout', authenticate, async (req, res) => {
  try {
    // Si c'est un agent, mettre hors ligne
    if (req.user.role === 'agent') {
      await Agent.findOneAndUpdate(
        { agentId: req.user.agentId },
        { online: false }
      );
    }
    
    res.json({
      success: true,
      message: 'Dekonekte av√®k siks√®'
    });
  } catch (error) {
    res.json({
      success: true,
      message: 'Dekonekte av√®k siks√®'
    });
  }
});

// === ROUTES D'INITIALISATION ===

// Initialiser les comptes par d√©faut
app.post('/api/init/default-accounts', async (req, res) => {
  try {
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // Cr√©er un agent par d√©faut
    const existingAgent = await Agent.findOne({ agentId: 'AGENT01' });
    if (!existingAgent) {
      const agent = new Agent({
        agentId: 'AGENT01',
        agentName: 'Ajan Prensipal',
        password: '123456',
        role: 'agent',
        funds: 50000,
        supervisorId: 'SUPER01'
      });
      await agent.save();
    }

    // Cr√©er un superviseur par d√©faut
    const existingSupervisor = await Supervisor.findOne({ username: 'supervisor' });
    if (!existingSupervisor) {
      const supervisor = new Supervisor({
        username: 'supervisor',
        password: '123456',
        name: 'Superviz√® Prensipal',
        role: 'supervisor',
        permissions: ['view_all', 'manage_agents', 'approve_funds', 'view_reports', 'delete_tickets', 'block_agents'],
        maxDeleteTime: 10
      });
      await supervisor.save();
    }

    // Cr√©er un propri√©taire par d√©faut
    const existingOwner = await Owner.findOne({ username: 'owner' });
    if (!existingOwner) {
      const owner = new Owner({
        username: 'owner',
        password: '123456',
        name: 'Pwopriyet√®',
        role: 'owner'
      });
      await owner.save();
    }

    res.json({
      success: true,
      message: 'Kont default kreye av√®k siks√®'
    });
  } catch (error) {
    console.error('Erreur initialisation:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® initializasyon'
    });
  }
});

// === ROUTES SUPERVISEUR ===

// Dashboard superviseur
app.get('/api/supervisor/dashboard', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // R√©cup√©rer les agents assign√©s
    const agents = await Agent.find({ supervisorId: req.user.username });
    
    // Calculer les statistiques
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const activeAgents = agents.filter(a => a.isActive).length;
    const onlineAgents = agents.filter(a => a.online && a.isActive).length;
    
    // R√©cup√©rer les tickets d'aujourd'hui
    const tickets = await Ticket.find({
      agentId: { $in: agents.map(a => a.agentId) },
      date: { $gte: today }
    });
    
    const totalTickets = tickets.length;
    const todaySales = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
    const totalCommission = todaySales * 0.05;
    
    // R√©cup√©rer les gains d'aujourd'hui
    const winners = await Winner.find({
      agentId: { $in: agents.map(a => a.agentId) },
      date: { $gte: today }
    });
    
    const totalWins = winners.reduce((sum, winner) => sum + winner.winningAmount, 0);
    
    // Agents r√©cemment actifs (derni√®res 2 heures)
    const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
    const recentAgents = await Agent.find({
      supervisorId: req.user.username,
      lastActivity: { $gte: twoHoursAgo },
      isActive: true
    }).limit(4);
    
    // Calculer les ventes par agent
    const agentsWithStats = await Promise.all(recentAgents.map(async (agent) => {
      const agentTickets = await Ticket.find({
        agentId: agent.agentId,
        date: { $gte: today }
      });
      
      const agentWinners = await Winner.find({
        agentId: agent.agentId,
        date: { $gte: today }
      });
      
      return {
        agentId: agent.agentId,
        agentName: agent.agentName,
        online: agent.online,
        isActive: agent.isActive,
        lastActivity: agent.lastActivity,
        location: agent.location,
        funds: agent.funds,
        todaySales: agentTickets.reduce((sum, t) => sum + t.total, 0),
        ticketCount: agentTickets.length,
        totalWins: agentWinners.reduce((sum, w) => sum + w.winningAmount, 0)
      };
    }));
    
    res.json({
      success: true,
      activeAgents,
      onlineAgents,
      totalTickets,
      todaySales,
      totalCommission,
      totalWins,
      recentAgents: agentsWithStats
    });
    
  } catch (error) {
    console.error('Erreur dashboard superviseur:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® charjman dashboard'
    });
  }
});

// R√©cup√©rer les agents assign√©s
app.get('/api/supervisor/agents', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const agents = await Agent.find({ supervisorId: req.user.username });
    
    // Calculer les statistiques pour chaque agent
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const agentsWithStats = await Promise.all(agents.map(async (agent) => {
      const agentTickets = await Ticket.find({
        agentId: agent.agentId,
        date: { $gte: today }
      });
      
      const agentWinners = await Winner.find({
        agentId: agent.agentId,
        date: { $gte: today }
      });
      
      return {
        agentId: agent.agentId,
        agentName: agent.agentName,
        online: agent.online,
        isActive: agent.isActive,
        lastActivity: agent.lastActivity,
        funds: agent.funds,
        todaySales: agentTickets.reduce((sum, t) => sum + t.total, 0),
        ticketCount: agentTickets.length,
        totalWins: agentWinners.reduce((sum, w) => sum + w.winningAmount, 0),
        location: agent.location
      };
    }));
    
    res.json({
      success: true,
      agents: agentsWithStats
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration agents superviseur:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration ajan yo'
    });
  }
});

// R√©cup√©rer les tickets d'un agent sp√©cifique
app.get('/api/supervisor/agents/:agentId/tickets', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { limit = 50 } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent appartient au superviseur
    const agent = await Agent.findOne({ 
      agentId: agentId,
      supervisorId: req.user.username 
    });
    
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    const tickets = await Ticket.find({ agentId: agentId })
      .sort({ date: -1 })
      .limit(parseInt(limit));
    
    res.json({
      success: true,
      agent: {
        agentId: agent.agentId,
        agentName: agent.agentName,
        isActive: agent.isActive,
        funds: agent.funds
      },
      tickets: tickets
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration tickets agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration tik√® ajan'
    });
  }
});

// R√©cup√©rer les rapports d'un agent
app.get('/api/supervisor/agents/:agentId/reports', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { period = 'today' } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent appartient au superviseur
    const agent = await Agent.findOne({ 
      agentId: agentId,
      supervisorId: req.user.username 
    });
    
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    // D√©finir la p√©riode
    let startDate = new Date();
    startDate.setHours(0, 0, 0, 0);
    
    if (period === 'week') {
      startDate.setDate(startDate.getDate() - 7);
    } else if (period === 'month') {
      startDate.setMonth(startDate.getMonth() - 1);
    } else if (period === 'year') {
      startDate.setFullYear(startDate.getFullYear() - 1);
    }
    
    // R√©cup√©rer les tickets
    const tickets = await Ticket.find({ 
      agentId: agentId,
      date: { $gte: startDate }
    });
    
    // R√©cup√©rer les gains
    const winners = await Winner.find({
      agentId: agentId,
      date: { $gte: startDate }
    });
    
    // Calculer les totaux
    const totalTickets = tickets.length;
    const totalBets = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
    const totalWins = winners.reduce((sum, winner) => sum + winner.winningAmount, 0);
    const totalLoss = totalBets - totalWins;
    const balance = totalWins - totalLoss;
    const successRate = totalTickets > 0 ? (winners.length / totalTickets) * 100 : 0;
    
    res.json({
      success: true,
      totalTickets,
      totalBets,
      totalWins,
      totalLoss,
      balance,
      successRate
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration rapports agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration rap√≤ ajan'
    });
  }
});

// R√©cup√©rer les gains d'un agent
app.get('/api/supervisor/agents/:agentId/winners', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { limit = 20 } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent appartient au superviseur
    const agent = await Agent.findOne({ 
      agentId: agentId,
      supervisorId: req.user.username 
    });
    
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    const winners = await Winner.find({ agentId: agentId })
      .sort({ date: -1 })
      .limit(parseInt(limit));
    
    res.json({
      success: true,
      winners: winners
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration gains agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration ganyen ajan'
    });
  }
});

// Bloquer/d√©bloquer un agent
app.post('/api/supervisor/agents/:agentId/block', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { block } = req.body; // true pour bloquer, false pour d√©bloquer
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent appartient au superviseur
    const agent = await Agent.findOne({ 
      agentId: agentId,
      supervisorId: req.user.username 
    });
    
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    // Bloquer/d√©bloquer l'agent
    agent.isActive = !block;
    await agent.save();
    
    res.json({
      success: true,
      message: `Ajan ${block ? 'bloke' : 'debloke'} av√®k siks√®`,
      isActive: agent.isActive
    });
    
  } catch (error) {
    console.error('Erreur blocage agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® bloke/debloke ajan'
    });
  }
});

// Supprimer les tickets r√©cents d'un agent
app.delete('/api/supervisor/tickets/recent', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    const { agentId, maxAgeMinutes = 10 } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent appartient au superviseur
    const agent = await Agent.findOne({ 
      agentId: agentId,
      supervisorId: req.user.username 
    });
    
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    // Calculer la date limite
    const maxAgeDate = new Date(Date.now() - maxAgeMinutes * 60 * 1000);
    
    // Supprimer les tickets r√©cents
    const result = await Ticket.deleteMany({
      agentId: agentId,
      date: { $gte: maxAgeDate }
    });
    
    res.json({
      success: true,
      message: `${result.deletedCount} tik√® resan yo efase`,
      deletedCount: result.deletedCount
    });
    
  } catch (error) {
    console.error('Erreur suppression tickets r√©cents:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® efase tik√® resan yo'
    });
  }
});

// Supprimer un ticket sp√©cifique
app.delete('/api/supervisor/tickets/:ticketId', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    const { ticketId } = req.params;
    const { agentId } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent appartient au superviseur
    const agent = await Agent.findOne({ 
      agentId: agentId,
      supervisorId: req.user.username 
    });
    
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    // V√©rifier que le ticket existe et appartient √† l'agent
    const ticket = await Ticket.findOne({ 
      ticketId: ticketId,
      agentId: agentId 
    });
    
    if (!ticket) {
      return res.status(404).json({
        success: false,
        message: 'Tik√® pa jwenn'
      });
    }
    
    // V√©rifier l'√¢ge du ticket
    const ticketAge = (Date.now() - new Date(ticket.date).getTime()) / (1000 * 60);
    const maxDeleteTime = req.user.maxDeleteTime || 10;
    
    if (ticketAge > maxDeleteTime) {
      return res.status(400).json({
        success: false,
        message: `Tik√® a tw√≤ vye pou efase (max: ${maxDeleteTime} minit)`
      });
    }
    
    // Supprimer le ticket
    await Ticket.deleteOne({ ticketId: ticketId });
    
    res.json({
      success: true,
      message: 'Tik√® efase av√®k siks√®'
    });
    
  } catch (error) {
    console.error('Erreur suppression ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® efase tik√®'
    });
  }
});

// Mettre √† jour les param√®tres du superviseur
app.post('/api/supervisor/settings', authenticate, requireRole(['supervisor']), async (req, res) => {
  try {
    const { maxDeleteTime } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    if (maxDeleteTime && (maxDeleteTime < 1 || maxDeleteTime > 60)) {
      return res.status(400).json({
        success: false,
        message: 'Tan maksim√≤m dwe ant 1 ak 60 minit'
      });
    }
    
    // Mettre √† jour les param√®tres
    await Supervisor.findByIdAndUpdate(req.user.id, {
      maxDeleteTime: maxDeleteTime
    });
    
    // Mettre √† jour le token si n√©cessaire
    const updatedSupervisor = await Supervisor.findById(req.user.id);
    const token = jwt.sign(
      {
        id: updatedSupervisor._id,
        username: updatedSupervisor.username,
        name: updatedSupervisor.name,
        role: 'supervisor',
        permissions: updatedSupervisor.permissions,
        maxDeleteTime: updatedSupervisor.maxDeleteTime
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({
      success: true,
      message: 'Anviw√≤nman mete ajou',
      token: token,
      maxDeleteTime: updatedSupervisor.maxDeleteTime
    });
    
  } catch (error) {
    console.error('Erreur mise √† jour param√®tres:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® mete ajou anviw√≤nman'
    });
  }
});

// === ROUTES EXISTANTES (conserv√©es) ===

// Gestion des agents (accessible par superviseur et propri√©taire)
app.get('/api/agents', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let query = {};
    
    // Si c'est un superviseur, ne voir que ses agents
    if (req.user.role === 'supervisor') {
      query.supervisorId = req.user.username;
    }
    
    const agents = await Agent.find(query, 'agentId agentName funds isActive supervisorId online lastActivity createdAt')
      .sort({ createdAt: -1 });
    
    res.json({
      success: true,
      agents: agents
    });
  } catch (error) {
    console.error('Erreur r√©cup√©ration agents:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration ajan yo'
    });
  }
});

// Cr√©er un nouvel agent
app.post('/api/agents', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { agentId, agentName, password, initialFunds, location } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier si l'agent existe d√©j√†
    const existingAgent = await Agent.findOne({ agentId: agentId.toUpperCase() });
    if (existingAgent) {
      return res.status(400).json({
        success: false,
        message: 'K√≤d ajan sa deja egziste'
      });
    }
    
    // D√©terminer le superviseur
    let supervisorId = req.user.username;
    if (req.user.role === 'owner' && req.body.supervisorId) {
      supervisorId = req.body.supervisorId;
    }
    
    const agent = new Agent({
      agentId: agentId.toUpperCase(),
      agentName: agentName,
      password: password || '123456',
      role: 'agent',
      funds: initialFunds || 10000,
      isActive: true,
      supervisorId: supervisorId,
      location: location || '',
      online: false
    });
    
    await agent.save();
    
    res.json({
      success: true,
      message: 'Ajan kreye av√®k siks√®',
      agent: {
        agentId: agent.agentId,
        agentName: agent.agentName,
        funds: agent.funds,
        supervisorId: agent.supervisorId
      }
    });
  } catch (error) {
    console.error('Erreur cr√©ation agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® kreye ajan'
    });
  }
});

// Mettre √† jour les fonds d'un agent
app.post('/api/agents/:agentId/funds', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { amount, type } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let query = { agentId: agentId };
    
    // Si c'est un superviseur, v√©rifier que l'agent lui appartient
    if (req.user.role === 'supervisor') {
      query.supervisorId = req.user.username;
    }
    
    const agent = await Agent.findOne(query);
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    let newBalance;
    if (type === 'add') {
      newBalance = agent.funds + amount;
    } else if (type === 'subtract') {
      newBalance = agent.funds - amount;
    } else {
      return res.status(400).json({
        success: false,
        message: 'Tip operasyon pa valab'
      });
    }
    
    agent.funds = newBalance;
    await agent.save();
    
    res.json({
      success: true,
      message: 'Fonds ajan mete ajou',
      newBalance: newBalance
    });
  } catch (error) {
    console.error('Erreur mise √† jour fonds agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® mete ajou fonds'
    });
  }
});

// Modifier le mot de passe d'un agent
app.post('/api/agents/:agentId/password', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { newPassword } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let query = { agentId: agentId };
    
    // Si c'est un superviseur, v√©rifier que l'agent lui appartient
    if (req.user.role === 'supervisor') {
      query.supervisorId = req.user.username;
    }
    
    const agent = await Agent.findOne(query);
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn oswa ou pa gen aks√®'
      });
    }
    
    agent.password = newPassword;
    await agent.save();
    
    res.json({
      success: true,
      message: 'Modpas ajan mete ajou'
    });
  } catch (error) {
    console.error('Erreur modification mot de passe:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® mete ajou modpas'
    });
  }
});

// Sauvegarder un ticket
app.post('/api/tickets/save', authenticate, requireRole(['agent']), async (req, res) => {
  try {
    const ticketData = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent a assez de fonds
    const agent = await Agent.findOne({ agentId: ticketData.agentId });
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn'
      });
    }
    
    if (agent.funds < ticketData.total) {
      return res.status(400).json({
        success: false,
        message: 'Fonds ensifizan'
      });
    }
    
    // G√©n√©rer un ID de ticket unique
    const ticketId = `T${Date.now()}${Math.floor(Math.random() * 1000)}`;
    
    const ticket = new Ticket({
      ...ticketData,
      ticketId: ticketId,
      date: new Date()
    });
    
    await ticket.save();
    
    // Mettre √† jour les fonds de l'agent (d√©duire le total)
    agent.funds -= ticketData.total;
    agent.lastActivity = new Date();
    await agent.save();
    
    res.status(201).json({
      success: true,
      message: 'Ticket sauvegard√© avec succ√®s',
      ticket: ticket
    });
  } catch (error) {
    console.error('Erreur sauvegarde ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la sauvegarde du ticket'
    });
  }
});

// R√©cup√©rer les tickets d'un agent
app.get('/api/tickets', authenticate, async (req, res) => {
  try {
    const { agentId } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier les permissions
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen aks√® a istorik ajan sa a'
      });
    }
    
    // Si c'est un superviseur, v√©rifier que l'agent lui appartient
    if (req.user.role === 'supervisor') {
      const agent = await Agent.findOne({ 
        agentId: agentId,
        supervisorId: req.user.username 
      });
      
      if (!agent) {
        return res.status(403).json({
          success: false,
          message: 'Ou pa gen aks√® a istorik ajan sa a'
        });
      }
    }
    
    const tickets = await Ticket.find({ agentId: agentId })
      .sort({ date: -1 })
      .limit(100);
    
    res.json({
      success: true,
      tickets: tickets
    });
  } catch (error) {
    console.error('Erreur r√©cup√©ration tickets:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des tickets'
    });
  }
});

// R√©cup√©rer TOUS les tickets (pour superviseur/propri√©taire)
app.get('/api/tickets/all', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { startDate, endDate, drawId, agentId } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let query = {};
    
    if (startDate && endDate) {
      query.date = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }
    
    if (drawId) {
      query.drawId = drawId;
    }
    
    // Si c'est un superviseur, ne voir que ses agents
    if (req.user.role === 'supervisor') {
      const agents = await Agent.find({ supervisorId: req.user.username }, 'agentId');
      query.agentId = { $in: agents.map(a => a.agentId) };
    }
    
    if (agentId) {
      query.agentId = agentId;
    }
    
    const tickets = await Ticket.find(query)
      .sort({ date: -1 })
      .limit(500);
    
    res.json({
      success: true,
      tickets: tickets
    });
  } catch (error) {
    console.error('Erreur r√©cup√©ration tous les tickets:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des tickets'
    });
  }
});

// R√©cup√©rer les rapports d'un agent
app.get('/api/reports', authenticate, async (req, res) => {
  try {
    const { agentId } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier les permissions
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen aks√® a rap√≤ ajan sa a'
      });
    }
    
    // Si c'est un superviseur, v√©rifier que l'agent lui appartient
    if (req.user.role === 'supervisor') {
      const agent = await Agent.findOne({ 
        agentId: agentId,
        supervisorId: req.user.username 
      });
      
      if (!agent) {
        return res.status(403).json({
          success: false,
          message: 'Ou pa gen aks√® a rap√≤ ajan sa a'
        });
      }
    }
    
    // R√©cup√©rer tous les tickets de l'agent
    const tickets = await Ticket.find({ agentId: agentId });
    
    // Calculer les totaux
    const totalTickets = tickets.length;
    const totalBets = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
    
    // Calculer les gains (√† partir des tickets v√©rifi√©s)
    const checkedTickets = tickets.filter(t => t.checked);
    const totalWins = checkedTickets.reduce((sum, ticket) => {
      const ticketGains = ticket.bets.reduce((betSum, bet) => betSum + (bet.gain || 0), 0);
      return sum + ticketGains;
    }, 0);
    
    // Calculer les pertes (total des paris - gains)
    const totalLoss = totalBets - totalWins;
    const balance = totalWins - totalLoss;
    
    // Breakdown par jeu
    const gameBreakdown = {};
    tickets.forEach(ticket => {
      ticket.bets.forEach(bet => {
        const game = bet.game;
        if (!gameBreakdown[game]) {
          gameBreakdown[game] = { count: 0, amount: 0 };
        }
        gameBreakdown[game].count += 1;
        gameBreakdown[game].amount += bet.amount;
      });
    });
    
    res.json({
      success: true,
      totalTickets: totalTickets,
      totalBets: totalBets,
      totalWins: totalWins,
      totalLoss: totalLoss,
      balance: balance,
      breakdown: gameBreakdown
    });
  } catch (error) {
    console.error('Erreur r√©cup√©ration rapports:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des rapports'
    });
  }
});

// R√©cup√©rer les rapports g√©n√©raux (pour superviseur/propri√©taire)
app.get('/api/reports/all', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { startDate, endDate, period = 'today' } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let query = {};
    
    // D√©finir la p√©riode si sp√©cifi√©e
    if (period === 'today') {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      query.date = { $gte: today };
    } else if (period === 'yesterday') {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      yesterday.setHours(0, 0, 0, 0);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      query.date = { $gte: yesterday, $lt: today };
    } else if (period === 'week') {
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);
      query.date = { $gte: weekAgo };
    } else if (period === 'month') {
      const monthAgo = new Date();
      monthAgo.setMonth(monthAgo.getMonth() - 1);
      query.date = { $gte: monthAgo };
    }
    
    if (startDate && endDate) {
      query.date = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }
    
    // Si c'est un superviseur, ne voir que ses agents
    let agentFilter = {};
    if (req.user.role === 'supervisor') {
      const agents = await Agent.find({ supervisorId: req.user.username }, 'agentId agentName');
      const agentIds = agents.map(a => a.agentId);
      query.agentId = { $in: agentIds };
      agentFilter = agents.reduce((obj, agent) => {
        obj[agent.agentId] = agent.agentName;
        return obj;
      }, {});
    }
    
    // R√©cup√©rer tous les tickets
    const tickets = await Ticket.find(query);
    
    // R√©cup√©rer tous les gagnants avec le m√™me filtre
    let winnerQuery = {};
    if (query.date) {
      winnerQuery.date = query.date;
    }
    if (query.agentId) {
      winnerQuery.agentId = query.agentId;
    }
    
    const winners = await Winner.find(winnerQuery);
    
    // Calculer les totaux g√©n√©raux
    const totalTickets = tickets.length;
    const totalBets = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
    const totalWins = winners.reduce((sum, winner) => sum + (winner.winningAmount || 0), 0);
    
    // Calculer les pertes
    const totalLoss = totalBets - totalWins;
    const balance = totalWins - totalLoss;
    
    // Breakdown par agent
    const agentBreakdown = {};
    tickets.forEach(ticket => {
      const agentId = ticket.agentId;
      if (!agentBreakdown[agentId]) {
        agentBreakdown[agentId] = { 
          agentName: agentFilter[agentId] || ticket.agentName,
          tickets: 0, 
          amount: 0,
          wins: 0
        };
      }
      agentBreakdown[agentId].tickets += 1;
      agentBreakdown[agentId].amount += ticket.total;
    });
    
    // Ajouter les gains par agent
    winners.forEach(winner => {
      if (agentBreakdown[winner.agentId]) {
        agentBreakdown[winner.agentId].wins += winner.winningAmount;
      }
    });
    
    // Calculer la balance pour chaque agent
    Object.keys(agentBreakdown).forEach(agentId => {
      agentBreakdown[agentId].balance = agentBreakdown[agentId].wins - (agentBreakdown[agentId].amount - agentBreakdown[agentId].wins);
    });
    
    res.json({
      success: true,
      totalTickets: totalTickets,
      totalBets: totalBets,
      totalWins: totalWins,
      totalLoss: totalLoss,
      balance: balance,
      agentBreakdown: agentBreakdown,
      activeAgents: Object.keys(agentBreakdown).length
    });
  } catch (error) {
    console.error('Erreur r√©cup√©ration rapports g√©n√©raux:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des rapports g√©n√©raux'
    });
  }
});

// R√©cup√©rer les gagnants
app.get('/api/winners', authenticate, async (req, res) => {
  try {
    const { agentId } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier les permissions
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen aks√® a ganyen ajan sa a'
      });
    }
    
    // Si c'est un superviseur, v√©rifier que l'agent lui appartient
    if (req.user.role === 'supervisor' && agentId) {
      const agent = await Agent.findOne({ 
        agentId: agentId,
        supervisorId: req.user.username 
      });
      
      if (!agent) {
        return res.status(403).json({
          success: false,
          message: 'Ou pa gen aks√® a ganyen ajan sa a'
        });
      }
    }
    
    let query = {};
    if (agentId) {
      query.agentId = agentId;
    } else if (req.user.role === 'supervisor') {
      // Pour superviseur sans agentId sp√©cifique, voir tous ses agents
      const agents = await Agent.find({ supervisorId: req.user.username }, 'agentId');
      query.agentId = { $in: agents.map(a => a.agentId) };
    }
    
    const winners = await Winner.find(query)
      .sort({ date: -1 })
      .limit(50);
    
    res.json({
      success: true,
      winners: winners
    });
  } catch (error) {
    console.error('Erreur r√©cup√©ration gagnants:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des gagnants'
    });
  }
});

// R√©cup√©rer TOUS les gagnants (pour superviseur/propri√©taire)
app.get('/api/winners/all', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { period = 'today' } = req.query;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let query = {};
    
    // D√©finir la p√©riode
    if (period === 'today') {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      query.date = { $gte: today };
    } else if (period === 'week') {
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);
      query.date = { $gte: weekAgo };
    } else if (period === 'month') {
      const monthAgo = new Date();
      monthAgo.setMonth(monthAgo.getMonth() - 1);
      query.date = { $gte: monthAgo };
    }
    
    // Si c'est un superviseur, ne voir que ses agents
    if (req.user.role === 'supervisor') {
      const agents = await Agent.find({ supervisorId: req.user.username }, 'agentId');
      query.agentId = { $in: agents.map(a => a.agentId) };
    }
    
    const winners = await Winner.find(query)
      .sort({ date: -1 })
      .limit(200);
    
    res.json({
      success: true,
      winners: winners
    });
  } catch (error) {
    console.error('Erreur r√©cup√©ration tous les gagnants:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des gagnants'
    });
  }
});

// Sauvegarder les gagnants
app.post('/api/winners/save', authenticate, requireRole(['agent']), async (req, res) => {
  try {
    const winnerData = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier si le gagnant existe d√©j√†
    const existingWinner = await Winner.findOne({
      ticketId: winnerData.ticketId,
      drawId: winnerData.drawId
    });
    
    let winner;
    if (existingWinner) {
      winner = await Winner.findOneAndUpdate(
        { _id: existingWinner._id },
        winnerData,
        { new: true }
      );
    } else {
      winner = new Winner(winnerData);
      await winner.save();
    }
    
    res.json({
      success: true,
      message: 'Gagnant sauvegard√© avec succ√®s',
      winner: winner
    });
  } catch (error) {
    console.error('Erreur sauvegarde gagnant:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la sauvegarde du gagnant'
    });
  }
});

// Mettre √† jour les fonds d'un agent
app.post('/api/agent/funds', authenticate, requireRole(['agent']), async (req, res) => {
  try {
    const { agentId, amount, type } = req.body;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // V√©rifier que l'agent ne modifie que ses propres fonds
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa ka modifye fonds ajan sa a'
      });
    }
    
    const agent = await Agent.findOne({ agentId: agentId });
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Agent non trouv√©'
      });
    }
    
    let newBalance;
    if (type === 'add') {
      newBalance = agent.funds + amount;
    } else if (type === 'subtract') {
      newBalance = agent.funds - amount;
    } else {
      return res.status(400).json({
        success: false,
        message: 'Type d\'op√©ration invalide'
      });
    }
    
    agent.funds = newBalance;
    await agent.save();
    
    res.json({
      success: true,
      message: 'Fonds mis √† jour avec succ√®s',
      newBalance: newBalance
    });
  } catch (error) {
    console.error('Erreur mise √† jour fonds:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise √† jour des fonds'
    });
  }
});

// Marquer un gagnant comme pay√©
app.post('/api/winners/:id/pay', authenticate, async (req, res) => {
  try {
    const { id } = req.params;
    
    // V√©rifier la connexion MongoDB
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const winner = await Winner.findById(id);
    if (!winner) {
      return res.status(404).json({
        success: false,
        message: 'Ganyen pa jwenn'
      });
    }
    
    // V√©rifier les permissions
    if (req.user.role === 'agent' && req.user.agentId !== winner.agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa ka peye ganyen sa a'
      });
    }
    
    // Si c'est un superviseur, v√©rifier que l'agent lui appartient
    if (req.user.role === 'supervisor') {
      const agent = await Agent.findOne({ 
        agentId: winner.agentId,
        supervisorId: req.user.username 
      });
      
      if (!agent) {
        return res.status(403).json({
          success: false,
          message: 'Ou pa gen aks√® a ganyen ajan sa a'
        });
      }
    }
    
    // V√©rifier si l'agent a assez de fonds (pour les agents)
    if (req.user.role === 'agent') {
      const agent = await Agent.findOne({ agentId: req.user.agentId });
      if (agent.funds < winner.winningAmount) {
        return res.status(400).json({
          success: false,
          message: 'Ou pa gen ase fonds pou peye ganyen sa a'
        });
      }
      
      // D√©duire les fonds
      agent.funds -= winner.winningAmount;
      await agent.save();
    }
    
    // Marquer comme pay√©
    winner.paid = true;
    await winner.save();
    
    res.json({
      success: true,
      message: 'Ganyen peye av√®k siks√®'
    });
  } catch (error) {
    console.error('Erreur paiement gagnant:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors du paiement du gagnant'
    });
  }
});

// V√©rifier le statut des tirages
app.get('/api/draws/status', async (req, res) => {
  try {
    const draws = [
      { id: 'mia_matin', name: 'Miami Matin', time: '13:30', blocked: false },
      { id: 'mia_soir', name: 'Miami Soir', time: '21:50', blocked: false },
      { id: 'ny_matin', name: 'New York Matin', time: '14:30', blocked: false },
      { id: 'ny_soir', name: 'New York Soir', time: '20:00', blocked: false },
      { id: 'ga_matin', name: 'Georgia Matin', time: '12:30', blocked: false },
      { id: 'ga_soir', name: 'Georgia Soir', time: '19:00', blocked: false },
      { id: 'tx_matin', name: 'Texas Matin', time: '11:30', blocked: false },
      { id: 'tx_soir', name: 'Texas Soir', time: '18:30', blocked: false },
      { id: 'tn_matin', name: 'Tunisia Matin', time: '10:00', blocked: false },
      { id: 'tn_soir', name: 'Tunisia Soir', time: '17:00', blocked: false }
    ];
    
    // V√©rifier si un tirage est bloqu√© (3 minutes avant l'heure)
    const now = new Date();
    draws.forEach(draw => {
      const [hours, minutes] = draw.time.split(':').map(Number);
      const drawTime = new Date();
      drawTime.setHours(hours, minutes, 0, 0);
      
      const blockedTime = new Date(drawTime.getTime() - (3 * 60 * 1000));
      draw.blocked = now >= blockedTime && now < drawTime;
    });
    
    res.json({
      success: true,
      draws: draws,
      serverTime: now.toISOString()
    });
  } catch (error) {
    console.error('Erreur statut tirages:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la v√©rification du statut des tirages'
    });
  }
});

// Route pour v√©rifier la connexion
app.get('/api/health', (req, res) => {
  res.json({
    success: true,
    message: 'API LOTATO PRO fonctionne',
    timestamp: new Date().toISOString(),
    version: '2.0.0',
    mongodbStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
    nodeEnv: process.env.NODE_ENV || 'development'
  });
});

// Route de test
app.get('/', (req, res) => {
  res.sendFile(__dirname + '/index.html');
});

// Routes pour les pages prot√©g√©es
app.get('/agent1.html', authenticate, (req, res) => {
  if (req.user.role === 'agent') {
    res.sendFile(__dirname + '/agent1.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

app.get('/supervisor.html', authenticate, (req, res) => {
  if (req.user.role === 'supervisor') {
    res.sendFile(__dirname + '/supervisor.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

app.get('/owner.html', authenticate, (req, res) => {
  if (req.user.role === 'owner') {
    res.sendFile(__dirname + '/owner.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

// Redirection pour responsable.html (alias de supervisor.html)
app.get('/responsable.html', authenticate, (req, res) => {
  if (req.user.role === 'supervisor') {
    res.sendFile(__dirname + '/supervisor.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

// Gestion des erreurs 404
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'Rout pa jwenn'
  });
});

// Middleware de gestion d'erreurs global
app.use((err, req, res, next) => {
  console.error('Erreur globale:', err);
  res.status(500).json({
    success: false,
    message: 'Er√® s√®v√® ent√®n'
  });
});

// D√©marrer le serveur
app.listen(PORT, () => {
  console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
  console.log(`üì° API disponible √† https://lotata-islp.onrender.com`);
  console.log(`üîê Page de connexion: https://lotata-islp.onrender.com/`);
  console.log(`üåê Environnement: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üóÑÔ∏è MongoDB URI: ${process.env.MONGODB_URI ? 'Configur√©e' : 'Non configur√©e'}`);
  console.log(`üë§ Comptes par d√©faut:`);
  console.log(`   - Agent: AGENT01 / 123456`);
  console.log(`   - Superviseur: supervisor / 123456`);
  console.log(`   - Propri√©taire: owner / 123456`);
  
  // V√©rifier la connexion MongoDB
  setTimeout(() => {
    if (mongoose.connection.readyState === 1) {
      console.log('‚úÖ MongoDB: Connect√©');
    } else {
      console.log('‚ö†Ô∏è MongoDB: En attente de connexion...');
    }
  }, 1000);
});