const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('.'));

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'lotato-pro-super-secret-key-2024';

// Connexion MongoDB
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/lotato';

console.log('üîß Initialisation de la connexion MongoDB...');

const mongooseOptions = {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  serverSelectionTimeoutMS: 10000,
  socketTimeoutMS: 45000,
  maxPoolSize: 10,
  retryWrites: true,
  w: 'majority'
};

const connectWithRetry = async () => {
  try {
    await mongoose.connect(MONGODB_URI, mongooseOptions);
    console.log('‚úÖ Connect√© √† MongoDB avec succ√®s');
    console.log(`üìä Base de donn√©es: ${mongoose.connection.db.databaseName}`);
  } catch (err) {
    console.error('‚ùå √âchec de connexion √† MongoDB:', err.message);
    console.log('üîÑ Nouvelle tentative dans 5 secondes...');
    setTimeout(connectWithRetry, 5000);
  }
};

mongoose.connection.on('connected', () => {
  console.log('üîó Mongoose connect√© √† MongoDB');
});

mongoose.connection.on('error', (err) => {
  console.error('‚ùå Erreur de connexion Mongoose:', err.message);
});

mongoose.connection.on('disconnected', () => {
  console.log('üîå Mongoose d√©connect√© de MongoDB');
});

connectWithRetry();

// === SCH√âMAS EXISTANTS ===
const ticketSchema = new mongoose.Schema({
  ticketId: { type: String, required: true, unique: true },
  agentId: { type: String, required: true },
  agentName: { type: String, required: true },
  drawId: { type: String, required: true },
  drawName: { type: String, required: true },
  bets: [{
    game: String,
    number: String,
    cleanNumber: String,
    amount: Number,
    isAutoGenerated: Boolean,
    specialType: String,
    gain: { type: Number, default: 0 }
  }],
  total: { type: Number, required: true },
  checked: { type: Boolean, default: false },
  date: { type: Date, default: Date.now }
});

const winnerSchema = new mongoose.Schema({
  ticketId: { type: String, required: true },
  agentId: { type: String, required: true },
  agentName: { type: String, required: true },
  drawId: { type: String, required: true },
  drawName: { type: String, required: true },
  gameType: { type: String, required: true },
  winningNumber: { type: String, required: true },
  winningAmount: { type: Number, required: true },
  customerName: { type: String, default: '' },
  paid: { type: Boolean, default: false },
  date: { type: Date, default: Date.now }
});

const agentSchema = new mongoose.Schema({
  agentId: { type: String, required: true, unique: true },
  agentName: { type: String, required: true },
  password: { type: String, required: true, default: '123456' },
  role: { type: String, default: 'agent' },
  funds: { type: Number, default: 10000 },
  lotteryName: { type: String, default: 'LOTATO PRO' },
  lotteryLogo: { type: String, default: '' },
  lotteryAddress: { type: String, default: '' },
  lotteryPhone: { type: String, default: '' },
  isActive: { type: Boolean, default: true },
  supervisorId: { type: String, required: true },
  lastActivity: { type: Date, default: Date.now },
  online: { type: Boolean, default: false },
  location: { type: String, default: '' },
  createdAt: { type: Date, default: Date.now }
});

const supervisorSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true, default: '123456' },
  name: { type: String, required: true },
  role: { type: String, default: 'supervisor' },
  permissions: [String],
  maxDeleteTime: { type: Number, default: 10 },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now }
});

const ownerSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true, default: '123456' },
  name: { type: String, required: true },
  role: { type: String, default: 'owner' },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now }
});

// === NOUVEAUX SCH√âMAS POUR PROPRI√âTAIRE ===
const drawConfigSchema = new mongoose.Schema({
  drawId: { type: String, required: true, unique: true },
  drawName: { type: String, required: true },
  drawTime: { type: String, required: true },
  isActive: { type: Boolean, default: true },
  isBlocked: { type: Boolean, default: false },
  lastResult: { type: String, default: '' },
  lastDrawDate: { type: Date, default: null },
  createdAt: { type: Date, default: Date.now }
});

const ballSchema = new mongoose.Schema({
  ballNumber: { type: String, required: true, unique: true },
  isBlocked: { type: Boolean, default: false },
  limitAmount: { type: Number, default: 0 },
  currentAmount: { type: Number, default: 0 },
  blockedAt: { type: Date, default: null },
  blockedBy: { type: String, default: '' }
});

const gameRuleSchema = new mongoose.Schema({
  gameType: { type: String, required: true, unique: true },
  gameName: { type: String, required: true },
  payouts: { type: Map, of: Number },
  isActive: { type: Boolean, default: true },
  updatedAt: { type: Date, default: Date.now }
});

const publishedDrawSchema = new mongoose.Schema({
  drawId: { type: String, required: true },
  drawName: { type: String, required: true },
  results: { type: [String], required: true },
  luckyNumber: { type: String, default: '' },
  publishedAt: { type: Date, default: Date.now },
  publishedBy: { type: String, required: true },
  source: { type: String, default: 'manual' },
  status: { type: String, default: 'published' }
});

const activityLogSchema = new mongoose.Schema({
  userId: { type: String, required: true },
  userRole: { type: String, required: true },
  action: { type: String, required: true },
  details: { type: String, default: '' },
  ipAddress: { type: String, default: '' },
  createdAt: { type: Date, default: Date.now }
});

// === MOD√àLES ===
const Ticket = mongoose.model('Ticket', ticketSchema);
const Winner = mongoose.model('Winner', winnerSchema);
const Agent = mongoose.model('Agent', agentSchema);
const Supervisor = mongoose.model('Supervisor', supervisorSchema);
const Owner = mongoose.model('Owner', ownerSchema);
const DrawConfig = mongoose.model('DrawConfig', drawConfigSchema);
const Ball = mongoose.model('Ball', ballSchema);
const GameRule = mongoose.model('GameRule', gameRuleSchema);
const PublishedDraw = mongoose.model('PublishedDraw', publishedDrawSchema);
const ActivityLog = mongoose.model('ActivityLog', activityLogSchema);

// Middleware d'authentification
const authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Token otantifikasyon obligatwa'
      });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'Token pa valab'
    });
  }
};

// Middleware de v√©rification de r√¥le
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen otorizasyon pou aksyon sa a'
      });
    }
    next();
  };
};

// === ROUTES D'AUTHENTIFICATION ===

// Connexion Propri√©taire (existant)
app.post('/api/auth/owner-login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const owner = await Owner.findOne({ 
      username: username.toLowerCase(),
      isActive: true 
    });
    
    if (!owner) {
      return res.status(401).json({
        success: false,
        message: 'Pwopriyet√® pa egziste'
      });
    }

    if (owner.password !== password) {
      return res.status(401).json({
        success: false,
        message: 'Modpas pa k√≤r√®k'
      });
    }

    const token = jwt.sign(
      {
        id: owner._id,
        username: owner.username,
        name: owner.name,
        role: 'owner'
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,
      message: 'Koneksyon reyisi',
      token: token,
      user: {
        id: owner._id,
        username: owner.username,
        name: owner.name,
        role: 'owner'
      }
    });
  } catch (error) {
    console.error('Erreur connexion propri√©taire:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® s√®v√® ent√®n'
    });
  }
});

// === ROUTES PROPRI√âTAIRE ===

// 1. Dashboard Propri√©taire
app.get('/api/owner/dashboard', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // R√©cup√©rer les statistiques
    const totalAgents = await Agent.countDocuments();
    const totalSupervisors = await Supervisor.countDocuments();
    const onlineAgents = await Agent.countDocuments({ online: true });
    const onlineSupervisors = await Supervisor.countDocuments({ online: true });
    
    // Calculer les ventes d'aujourd'hui
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const todayTickets = await Ticket.find({ date: { $gte: today } });
    const todaySales = todayTickets.reduce((sum, ticket) => sum + ticket.total, 0);
    const todayWinners = await Winner.find({ date: { $gte: today } });
    const todayWins = todayWinners.reduce((sum, winner) => sum + winner.winningAmount, 0);
    
    // R√©cup√©rer les tirages actifs
    const activeDraws = await DrawConfig.countDocuments({ isActive: true });
    const totalDraws = await DrawConfig.countDocuments();
    
    // R√©cup√©rer les boules bloqu√©es
    const blockedBalls = await Ball.countDocuments({ isBlocked: true });
    
    // R√©cup√©rer les activit√©s r√©centes
    const recentActivities = await ActivityLog.find()
      .sort({ createdAt: -1 })
      .limit(5);
    
    res.json({
      success: true,
      stats: {
        totalAgents,
        totalSupervisors,
        onlineAgents,
        onlineSupervisors,
        todaySales,
        todayWins,
        activeDraws,
        totalDraws,
        blockedBalls
      },
      recentActivities
    });
    
  } catch (error) {
    console.error('Erreur dashboard propri√©taire:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® charjman dashboard'
    });
  }
});

// 2. R√©cup√©rer tous les utilisateurs
app.get('/api/owner/users', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const agents = await Agent.find().select('-password');
    const supervisors = await Supervisor.find().select('-password');
    
    // Pour chaque superviseur, compter le nombre d'agents
    const supervisorsWithAgentCount = await Promise.all(supervisors.map(async (supervisor) => {
      const agentCount = await Agent.countDocuments({ supervisorId: supervisor.username });
      return {
        ...supervisor.toObject(),
        agentCount
      };
    }));
    
    res.json({
      success: true,
      agents,
      supervisors: supervisorsWithAgentCount
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration utilisateurs:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration itilizat√® yo'
    });
  }
});

// 3. Cr√©er un nouvel utilisateur
app.post('/api/owner/users', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { type, username, name, password, email, phone, supervisorId, location, commission } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    if (type === 'supervisor') {
      // Cr√©er un superviseur
      const existingSupervisor = await Supervisor.findOne({ username });
      if (existingSupervisor) {
        return res.status(400).json({
          success: false,
          message: 'Non itilizat√® sa deja egziste'
        });
      }
      
      const supervisor = new Supervisor({
        username,
        password,
        name,
        email,
        phone
      });
      
      await supervisor.save();
      
      // Log d'activit√©
      await ActivityLog.create({
        userId: req.user.id,
        userRole: 'owner',
        action: 'create_supervisor',
        details: `Superviseur ${name} cr√©√©`
      });
      
      res.json({
        success: true,
        message: 'Superviz√® kreye av√®k siks√®',
        user: supervisor
      });
      
    } else if (type === 'agent') {
      // Cr√©er un agent
      const existingAgent = await Agent.findOne({ agentId: username.toUpperCase() });
      if (existingAgent) {
        return res.status(400).json({
          success: false,
          message: 'K√≤d ajan sa deja egziste'
        });
      }
      
      // V√©rifier que le superviseur existe
      const supervisor = await Supervisor.findOne({ username: supervisorId });
      if (!supervisor) {
        return res.status(400).json({
          success: false,
          message: 'Superviz√® pa egziste'
        });
      }
      
      const agent = new Agent({
        agentId: username.toUpperCase(),
        agentName: name,
        password,
        email,
        phone,
        supervisorId: supervisorId,
        location,
        commission: commission || 5
      });
      
      await agent.save();
      
      // Log d'activit√©
      await ActivityLog.create({
        userId: req.user.id,
        userRole: 'owner',
        action: 'create_agent',
        details: `Agent ${name} cr√©√© pour superviseur ${supervisorId}`
      });
      
      res.json({
        success: true,
        message: 'Ajan kreye av√®k siks√®',
        user: agent
      });
    } else {
      return res.status(400).json({
        success: false,
        message: 'Tip itilizat√® pa valab'
      });
    }
    
  } catch (error) {
    console.error('Erreur cr√©ation utilisateur:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® kreye itilizat√®'
    });
  }
});

// 4. Bloquer/d√©bloquer un utilisateur
app.post('/api/owner/users/:userId/block', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { userId } = req.params;
    const { block } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // Chercher dans les agents
    let user = await Agent.findOne({ agentId: userId });
    let userType = 'agent';
    
    if (!user) {
      // Chercher dans les superviseurs
      user = await Supervisor.findOne({ username: userId });
      userType = 'supervisor';
    }
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Itilizat√® pa jwenn'
      });
    }
    
    user.isActive = !block;
    await user.save();
    
    // Si c'est un superviseur et qu'on le bloque, bloquer aussi ses agents
    if (userType === 'supervisor' && block) {
      await Agent.updateMany(
        { supervisorId: userId },
        { isActive: false }
      );
    }
    
    // Log d'activit√©
    await ActivityLog.create({
      userId: req.user.id,
      userRole: 'owner',
      action: block ? 'block_user' : 'unblock_user',
      details: `${userType} ${userId} ${block ? 'bloqu√©' : 'd√©bloqu√©'}`
    });
    
    res.json({
      success: true,
      message: `Itilizat√® ${block ? 'bloke' : 'debloke'} av√®k siks√®`,
      isActive: user.isActive
    });
    
  } catch (error) {
    console.error('Erreur blocage utilisateur:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® bloke/debloke itilizat√®'
    });
  }
});

// 5. Transf√©rer un agent
app.post('/api/owner/users/:agentId/transfer', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { newSupervisorId } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const agent = await Agent.findOne({ agentId });
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn'
      });
    }
    
    const newSupervisor = await Supervisor.findOne({ username: newSupervisorId });
    if (!newSupervisor) {
      return res.status(404).json({
        success: false,
        message: 'Nouvo superviseur pa jwenn'
      });
    }
    
    const oldSupervisorId = agent.supervisorId;
    
    agent.supervisorId = newSupervisorId;
    await agent.save();
    
    // Log d'activit√©
    await ActivityLog.create({
      userId: req.user.id,
      userRole: 'owner',
      action: 'transfer_agent',
      details: `Agent ${agentId} transf√©r√© de ${oldSupervisorId} √† ${newSupervisorId}`
    });
    
    res.json({
      success: true,
      message: 'Ajan transfere av√®k siks√®',
      newSupervisor: newSupervisor.name
    });
    
  } catch (error) {
    console.error('Erreur transfert agent:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® transfere ajan'
    });
  }
});

// 6. Gestion des tirages
app.get('/api/owner/draws', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const draws = await DrawConfig.find().sort({ drawTime: 1 });
    
    // Calculer les ventes pour chaque tirage
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const drawsWithSales = await Promise.all(draws.map(async (draw) => {
      const sales = await Ticket.aggregate([
        {
          $match: {
            drawId: draw.drawId,
            date: { $gte: today }
          }
        },
        {
          $group: {
            _id: null,
            total: { $sum: '$total' }
          }
        }
      ]);
      
      return {
        ...draw.toObject(),
        sales: sales.length > 0 ? sales[0].total : 0
      };
    }));
    
    res.json({
      success: true,
      draws: drawsWithSales
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration tirages:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration tirages'
    });
  }
});

// 7. Activer/d√©sactiver un tirage
app.post('/api/owner/draws/:drawId/toggle', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { drawId } = req.params;
    const { isActive } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const draw = await DrawConfig.findOne({ drawId });
    if (!draw) {
      return res.status(404).json({
        success: false,
        message: 'Tiraj pa jwenn'
      });
    }
    
    draw.isActive = isActive;
    await draw.save();
    
    // Log d'activit√©
    await ActivityLog.create({
      userId: req.user.id,
      userRole: 'owner',
      action: isActive ? 'activate_draw' : 'deactivate_draw',
      details: `Tiraj ${draw.drawName} ${isActive ? 'activ√©' : 'd√©sactiv√©'}`
    });
    
    res.json({
      success: true,
      message: `Tiraj ${isActive ? 'aktive' : 'dezaktiye'} av√®k siks√®`,
      isActive: draw.isActive
    });
    
  } catch (error) {
    console.error('Erreur modification tirage:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® modifye tiraj'
    });
  }
});

// 8. Gestion des boules
app.get('/api/owner/balls', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const balls = await Ball.find().sort({ ballNumber: 1 });
    
    // Si aucune boule n'existe, initialiser
    if (balls.length === 0) {
      const ballArray = [];
      for (let i = 0; i < 100; i++) {
        const num = i.toString().padStart(2, '0');
        ballArray.push({
          ballNumber: num,
          isBlocked: false,
          limitAmount: 0,
          currentAmount: 0
        });
      }
      await Ball.insertMany(ballArray);
      
      const newBalls = await Ball.find().sort({ ballNumber: 1 });
      return res.json({
        success: true,
        balls: newBalls
      });
    }
    
    res.json({
      success: true,
      balls
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration boules:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration boul yo'
    });
  }
});

// 9. Bloquer/d√©bloquer une boule
app.post('/api/owner/balls/:ballNumber/block', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { ballNumber } = req.params;
    const { isBlocked } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let ball = await Ball.findOne({ ballNumber });
    
    if (!ball) {
      ball = new Ball({
        ballNumber,
        isBlocked,
        blockedAt: isBlocked ? new Date() : null,
        blockedBy: req.user.username
      });
    } else {
      ball.isBlocked = isBlocked;
      ball.blockedAt = isBlocked ? new Date() : null;
      ball.blockedBy = isBlocked ? req.user.username : '';
    }
    
    await ball.save();
    
    // Log d'activit√©
    await ActivityLog.create({
      userId: req.user.id,
      userRole: 'owner',
      action: isBlocked ? 'block_ball' : 'unblock_ball',
      details: `Boule ${ballNumber} ${isBlocked ? 'bloqu√©e' : 'd√©bloqu√©e'}`
    });
    
    res.json({
      success: true,
      message: `Boule ${ballNumber} ${isBlocked ? 'bloke' : 'debloke'} av√®k siks√®`,
      ball
    });
    
  } catch (error) {
    console.error('Erreur blocage boule:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® bloke/debloke boule'
    });
  }
});

// 10. D√©finir une limite pour une boule
app.post('/api/owner/balls/:ballNumber/limit', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { ballNumber } = req.params;
    const { limitAmount } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    let ball = await Ball.findOne({ ballNumber });
    
    if (!ball) {
      ball = new Ball({
        ballNumber,
        limitAmount,
        currentAmount: 0
      });
    } else {
      ball.limitAmount = limitAmount;
    }
    
    await ball.save();
    
    // Log d'activit√©
    await ActivityLog.create({
      userId: req.user.id,
      userRole: 'owner',
      action: 'set_ball_limit',
      details: `Limite d√©finie pour boule ${ballNumber}: ${limitAmount} Gdes`
    });
    
    res.json({
      success: true,
      message: `Limit pou boule ${ballNumber} defini av√®k siks√®`,
      ball
    });
    
  } catch (error) {
    console.error('Erreur d√©finition limite:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® defini limit boule'
    });
  }
});

// 11. R√®gles de jeu
app.get('/api/owner/rules', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const rules = await GameRule.find();
    
    // Si aucune r√®gle n'existe, initialiser
    if (rules.length === 0) {
      const defaultRules = [
        {
          gameType: 'borlette',
          gameName: 'Borlette',
          payouts: { lot1: 60, lot2: 20, lot3: 10 },
          isActive: true
        },
        {
          gameType: 'lotto3',
          gameName: 'Lotto 3',
          payouts: { win: 500 },
          isActive: true
        },
        {
          gameType: 'lotto4',
          gameName: 'Lotto 4',
          payouts: { win: 1000 },
          isActive: true
        },
        {
          gameType: 'lotto5',
          gameName: 'Lotto 5',
          payouts: { win: 5000 },
          isActive: true
        },
        {
          gameType: 'mariage',
          gameName: 'Mariage',
          payouts: { win: 1000 },
          isActive: true
        }
      ];
      
      await GameRule.insertMany(defaultRules);
      const newRules = await GameRule.find();
      return res.json({
        success: true,
        rules: newRules
      });
    }
    
    res.json({
      success: true,
      rules
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration r√®gles:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration r√®glement yo'
    });
  }
});

// 12. Modifier une r√®gle
app.put('/api/owner/rules/:gameType', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { gameType } = req.params;
    const { payouts, isActive } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const rule = await GameRule.findOneAndUpdate(
      { gameType },
      { payouts, isActive, updatedAt: new Date() },
      { new: true, upsert: true }
    );
    
    // Log d'activit√©
    await ActivityLog.create({
      userId: req.user.id,
      userRole: 'owner',
      action: 'update_rule',
      details: `R√®gle ${gameType} mise √† jour`
    });
    
    res.json({
      success: true,
      message: 'R√®glement mete ajou av√®k siks√®',
      rule
    });
    
  } catch (error) {
    console.error('Erreur modification r√®gle:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® mete ajou r√®glement'
    });
  }
});

// 13. Publication de tirage
app.post('/api/owner/draws/publish', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { drawName, results, luckyNumber, publishedBy, source } = req.body;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    if (!results || !Array.isArray(results) || results.length < 5) {
      return res.status(400).json({
        success: false,
        message: '5 rezilta obligatwa'
      });
    }
    
    const drawId = `DRAW-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const publishedDraw = new PublishedDraw({
      drawId,
      drawName,
      results: results.map(r => r.toString().padStart(2, '0')),
      luckyNumber: luckyNumber ? luckyNumber.toString().padStart(2, '0') : '',
      publishedBy,
      source: source || 'manual'
    });
    
    await publishedDraw.save();
    
    // Mettre √† jour le tirage correspondant
    const drawConfig = await DrawConfig.findOne({ drawName });
    if (drawConfig) {
      drawConfig.lastResult = results.join(',');
      drawConfig.lastDrawDate = new Date();
      await drawConfig.save();
    }
    
    // Log d'activit√©
    await ActivityLog.create({
      userId: req.user.id,
      userRole: 'owner',
      action: 'publish_draw',
      details: `Tirage ${drawName} publi√©: ${results.join(',')}`
    });
    
    res.json({
      success: true,
      message: 'Tiraj pibliye av√®k siks√®',
      draw: publishedDraw
    });
    
  } catch (error) {
    console.error('Erreur publication tirage:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® pibliye tiraj'
    });
  }
});

// 14. Historique des publications
app.get('/api/owner/draws/history', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { limit = 20 } = req.query;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const history = await PublishedDraw.find()
      .sort({ publishedAt: -1 })
      .limit(parseInt(limit));
    
    res.json({
      success: true,
      history
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration historique:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration istorik'
    });
  }
});

// 15. Journal d'activit√©
app.get('/api/owner/activity', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    const { limit = 50 } = req.query;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    const activities = await ActivityLog.find()
      .sort({ createdAt: -1 })
      .limit(parseInt(limit));
    
    res.json({
      success: true,
      activities
    });
    
  } catch (error) {
    console.error('Erreur r√©cup√©ration journal:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® r√©cup√©ration jounal aktivite'
    });
  }
});

// 16. Initialisation des donn√©es par d√©faut
app.post('/api/owner/init-defaults', authenticate, requireRole(['owner']), async (req, res) => {
  try {
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        success: false,
        message: 'Sist√®m nan ap travay, tanpri eseye ank√≤ nan k√®k moman'
      });
    }
    
    // Tirages par d√©faut
    const defaultDraws = [
      { drawId: 'flo_matin', drawName: 'Florida Matin', drawTime: '13:30', isActive: true },
      { drawId: 'flo_soir', drawName: 'Florida Soir', drawTime: '21:50', isActive: true },
      { drawId: 'ny_matin', drawName: 'New York Matin', drawTime: '14:30', isActive: true },
      { drawId: 'ny_soir', drawName: 'New York Soir', drawTime: '20:00', isActive: true },
      { drawId: 'ga_matin', drawName: 'Georgia Matin', drawTime: '12:30', isActive: false },
      { drawId: 'ga_soir', drawName: 'Georgia Soir', drawTime: '19:00', isActive: true },
      { drawId: 'tx_matin', drawName: 'Texas Matin', drawTime: '11:30', isActive: true },
      { drawId: 'tx_soir', drawName: 'Texas Soir', drawTime: '18:30', isActive: true },
      { drawId: 'tn_matin', drawName: 'Tunisia Matin', drawTime: '10:00', isActive: true },
      { drawId: 'tn_soir', drawName: 'Tunisia Soir', drawTime: '17:00', isActive: false }
    ];
    
    // Boules par d√©faut (0-99)
    const defaultBalls = Array.from({ length: 100 }, (_, i) => ({
      ballNumber: i.toString().padStart(2, '0'),
      isBlocked: false,
      limitAmount: 0,
      currentAmount: 0
    }));
    
    // R√®gles par d√©faut
    const defaultRules = [
      { gameType: 'borlette', gameName: 'Borlette', payouts: { lot1: 60, lot2: 20, lot3: 10 }, isActive: true },
      { gameType: 'lotto3', gameName: 'Lotto 3', payouts: { win: 500 }, isActive: true },
      { gameType: 'lotto4', gameName: 'Lotto 4', payouts: { win: 1000 }, isActive: true },
      { gameType: 'lotto5', gameName: 'Lotto 5', payouts: { win: 5000 }, isActive: true },
      { gameType: 'mariage', gameName: 'Mariage', payouts: { win: 1000 }, isActive: true }
    ];
    
    // V√©rifier et cr√©er les tirages
    for (const draw of defaultDraws) {
      const existing = await DrawConfig.findOne({ drawId: draw.drawId });
      if (!existing) {
        await DrawConfig.create(draw);
      }
    }
    
    // V√©rifier et cr√©er les boules
    const ballCount = await Ball.countDocuments();
    if (ballCount === 0) {
      await Ball.insertMany(defaultBalls);
    }
    
    // V√©rifier et cr√©er les r√®gles
    const ruleCount = await GameRule.countDocuments();
    if (ruleCount === 0) {
      await GameRule.insertMany(defaultRules);
    }
    
    res.json({
      success: true,
      message: 'Done default inisyalize av√®k siks√®'
    });
    
  } catch (error) {
    console.error('Erreur initialisation:', error);
    res.status(500).json({
      success: false,
      message: 'Er√® inisyalizasyon'
    });
  }
});

// === ROUTES SUPERVISEUR (existant) ===
// ... (garder toutes les routes superviseur existantes)

// === ROUTES AGENT (existant) ===
// ... (garder toutes les routes agent existantes)

// Route de v√©rification
app.get('/api/health', (req, res) => {
  res.json({
    success: true,
    message: 'API LOTATO PRO fonctionne',
    timestamp: new Date().toISOString(),
    version: '3.0.0',
    mongodbStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
    nodeEnv: process.env.NODE_ENV || 'development'
  });
});

// Route de test
app.get('/', (req, res) => {
  res.sendFile(__dirname + '/index.html');
});

// Routes pour les pages prot√©g√©es
app.get('/agent1.html', authenticate, (req, res) => {
  if (req.user.role === 'agent') {
    res.sendFile(__dirname + '/agent1.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

app.get('/supervisor.html', authenticate, (req, res) => {
  if (req.user.role === 'supervisor') {
    res.sendFile(__dirname + '/supervisor.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

app.get('/owner.html', authenticate, (req, res) => {
  if (req.user.role === 'owner') {
    res.sendFile(__dirname + '/owner.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

// Redirection pour responsable.html
app.get('/responsable.html', authenticate, (req, res) => {
  if (req.user.role === 'supervisor') {
    res.sendFile(__dirname + '/supervisor.html');
  } else {
    res.status(403).send('Acc√®s non autoris√©');
  }
});

// Gestion des erreurs 404
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'Rout pa jwenn'
  });
});

// Middleware de gestion d'erreurs global
app.use((err, req, res, next) => {
  console.error('Erreur globale:', err);
  res.status(500).json({
    success: false,
    message: 'Er√® s√®v√® ent√®n'
  });
});

// D√©marrer le serveur
app.listen(PORT, () => {
  console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
  console.log(`üì° API disponible √† http://localhost:${PORT}`);
  console.log(`üîê Page de connexion: http://localhost:${PORT}/`);
  console.log(`üåê Environnement: ${process.env.NODE_ENV || 'development'}`);
  
  // V√©rifier la connexion MongoDB
  setTimeout(() => {
    if (mongoose.connection.readyState === 1) {
      console.log('‚úÖ MongoDB: Connect√©');
    } else {
      console.log('‚ö†Ô∏è MongoDB: En attente de connexion...');
    }
  }, 1000);
});