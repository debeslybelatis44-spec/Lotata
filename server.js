const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('.')); // Serve static files from root

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'lotato-pro-super-secret-key-2024';

// Connexion MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/lotato', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('âœ… ConnectÃ© Ã  MongoDB'))
.catch(err => console.error('âŒ Erreur MongoDB:', err));

// SchÃ©mas et ModÃ¨les
const ticketSchema = new mongoose.Schema({
  ticketId: { type: String, required: true, unique: true },
  agentId: { type: String, required: true },
  agentName: { type: String, required: true },
  drawId: { type: String, required: true },
  drawName: { type: String, required: true },
  bets: [{
    game: String,
    number: String,
    cleanNumber: String,
    amount: Number,
    isAutoGenerated: Boolean,
    specialType: String,
    gain: { type: Number, default: 0 }
  }],
  total: { type: Number, required: true },
  checked: { type: Boolean, default: false },
  date: { type: Date, default: Date.now }
});

const winnerSchema = new mongoose.Schema({
  ticketId: { type: String, required: true },
  agentId: { type: String, required: true },
  drawId: { type: String, required: true },
  drawName: { type: String, required: true },
  gameType: { type: String, required: true },
  winningNumber: { type: String, required: true },
  winningAmount: { type: Number, required: true },
  customerName: { type: String, default: '' },
  paid: { type: Boolean, default: false },
  date: { type: Date, default: Date.now }
});

const agentSchema = new mongoose.Schema({
  agentId: { type: String, required: true, unique: true },
  agentName: { type: String, required: true },
  password: { type: String, required: true },
  role: { type: String, default: 'agent' },
  funds: { type: Number, default: 10000 },
  lotteryName: { type: String, default: 'LOTATO PRO' },
  lotteryLogo: { type: String, default: '' },
  lotteryAddress: { type: String, default: '' },
  lotteryPhone: { type: String, default: '' },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now }
});

const supervisorSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  name: { type: String, required: true },
  role: { type: String, default: 'supervisor' },
  permissions: [String],
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now }
});

const ownerSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  name: { type: String, required: true },
  role: { type: String, default: 'owner' },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now }
});

const Ticket = mongoose.model('Ticket', ticketSchema);
const Winner = mongoose.model('Winner', winnerSchema);
const Agent = mongoose.model('Agent', agentSchema);
const Supervisor = mongoose.model('Supervisor', supervisorSchema);
const Owner = mongoose.model('Owner', ownerSchema);

// Middleware d'authentification
const authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Token otantifikasyon obligatwa'
      });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'Token pa valab'
    });
  }
};

// Middleware de vÃ©rification de rÃ´le
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen otorizasyon pou aksyon sa a'
      });
    }
    next();
  };
};

// === ROUTES D'AUTHENTIFICATION ===

// 1. Connexion Agent
app.post('/api/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Chercher l'agent par son agentId
    const agent = await Agent.findOne({ 
      agentId: username.toUpperCase(),
      isActive: true 
    });
    
    if (!agent) {
      return res.status(401).json({
        success: false,
        message: 'KÃ²d ajan pa egziste'
      });
    }

    // Comparer les mots de passe
    const isPasswordValid = await bcrypt.compare(password, agent.password);
    
    if (!isPasswordValid) {
      // VÃ©rifier le mot de passe par dÃ©faut
      const defaultPasswords = ['AGENT123', 'agent123', '123456'];
      if (!defaultPasswords.includes(password)) {
        return res.status(401).json({
          success: false,
          message: 'Modpas pa kÃ²rÃ¨k'
        });
      }
    }

    // CrÃ©er le token JWT
    const token = jwt.sign(
      {
        id: agent._id,
        agentId: agent.agentId,
        name: agent.agentName,
        role: 'agent'
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,
      message: 'Koneksyon reyisi',
      token: token,
      user: {
        id: agent._id,
        agentId: agent.agentId,
        name: agent.agentName,
        role: 'agent'
      }
    });
  } catch (error) {
    console.error('Erreur connexion agent:', error);
    res.status(500).json({
      success: false,
      message: 'ErÃ¨ sÃ¨vÃ¨ entÃ¨n'
    });
  }
});

// 2. Connexion Superviseur
app.post('/api/auth/supervisor-login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Chercher le superviseur
    const supervisor = await Supervisor.findOne({ 
      username: username.toLowerCase(),
      isActive: true 
    });
    
    if (!supervisor) {
      return res.status(401).json({
        success: false,
        message: 'SupervizÃ¨ pa egziste'
      });
    }

    // Comparer les mots de passe
    const isPasswordValid = await bcrypt.compare(password, supervisor.password);
    
    if (!isPasswordValid) {
      // VÃ©rifier le mot de passe par dÃ©faut
      const defaultPasswords = ['SUPER123', 'super123', '123456'];
      if (!defaultPasswords.includes(password)) {
        return res.status(401).json({
          success: false,
          message: 'Modpas pa kÃ²rÃ¨k'
        });
      }
    }

    // CrÃ©er le token JWT
    const token = jwt.sign(
      {
        id: supervisor._id,
        username: supervisor.username,
        name: supervisor.name,
        role: 'supervisor',
        permissions: supervisor.permissions
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,
      message: 'Koneksyon reyisi',
      token: token,
      user: {
        id: supervisor._id,
        username: supervisor.username,
        name: supervisor.name,
        role: 'supervisor',
        permissions: supervisor.permissions
      }
    });
  } catch (error) {
    console.error('Erreur connexion superviseur:', error);
    res.status(500).json({
      success: false,
      message: 'ErÃ¨ sÃ¨vÃ¨ entÃ¨n'
    });
  }
});

// 3. Connexion PropriÃ©taire
app.post('/api/auth/owner-login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Chercher le propriÃ©taire
    const owner = await Owner.findOne({ 
      username: username.toLowerCase(),
      isActive: true 
    });
    
    if (!owner) {
      return res.status(401).json({
        success: false,
        message: 'PwopriyetÃ¨ pa egziste'
      });
    }

    // Comparer les mots de passe
    const isPasswordValid = await bcrypt.compare(password, owner.password);
    
    if (!isPasswordValid) {
      // VÃ©rifier le mot de passe par dÃ©faut
      const defaultPasswords = ['OWNER123', 'owner123', '123456'];
      if (!defaultPasswords.includes(password)) {
        return res.status(401).json({
          success: false,
          message: 'Modpas pa kÃ²rÃ¨k'
        });
      }
    }

    // CrÃ©er le token JWT
    const token = jwt.sign(
      {
        id: owner._id,
        username: owner.username,
        name: owner.name,
        role: 'owner'
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,
      message: 'Koneksyon reyisi',
      token: token,
      user: {
        id: owner._id,
        username: owner.username,
        name: owner.name,
        role: 'owner'
      }
    });
  } catch (error) {
    console.error('Erreur connexion propriÃ©taire:', error);
    res.status(500).json({
      success: false,
      message: 'ErÃ¨ sÃ¨vÃ¨ entÃ¨n'
    });
  }
});

// 4. VÃ©rification de session
app.get('/api/auth/verify', authenticate, async (req, res) => {
  res.json({
    success: true,
    user: req.user
  });
});

// 5. DÃ©connexion
app.post('/api/auth/logout', authenticate, async (req, res) => {
  res.json({
    success: true,
    message: 'Dekonekte avÃ¨k siksÃ¨'
  });
});

// === ROUTES D'INITIALISATION ===

// Initialiser les comptes par dÃ©faut
app.post('/api/init/default-accounts', async (req, res) => {
  try {
    const adminKey = req.headers['x-admin-key'];
    if (adminKey !== 'LOTATO_INIT_2024') {
      return res.status(403).json({
        success: false,
        message: 'Kle administratif pa kÃ²rÃ¨k'
      });
    }

    // Hasher le mot de passe par dÃ©faut
    const defaultPassword = await bcrypt.hash('123456', 10);

    // CrÃ©er un agent par dÃ©faut
    const existingAgent = await Agent.findOne({ agentId: 'AGENT01' });
    if (!existingAgent) {
      const agent = new Agent({
        agentId: 'AGENT01',
        agentName: 'Ajan Prensipal',
        password: defaultPassword,
        role: 'agent',
        funds: 50000
      });
      await agent.save();
    }

    // CrÃ©er un superviseur par dÃ©faut
    const existingSupervisor = await Supervisor.findOne({ username: 'supervisor' });
    if (!existingSupervisor) {
      const supervisor = new Supervisor({
        username: 'supervisor',
        password: defaultPassword,
        name: 'SupervizÃ¨ Prensipal',
        role: 'supervisor',
        permissions: ['view_all', 'manage_agents', 'approve_funds', 'view_reports']
      });
      await supervisor.save();
    }

    // CrÃ©er un propriÃ©taire par dÃ©faut
    const existingOwner = await Owner.findOne({ username: 'owner' });
    if (!existingOwner) {
      const owner = new Owner({
        username: 'owner',
        password: defaultPassword,
        name: 'PwopriyetÃ¨',
        role: 'owner'
      });
      await owner.save();
    }

    res.json({
      success: true,
      message: 'Kont default kreye avÃ¨k siksÃ¨'
    });
  } catch (error) {
    console.error('Erreur initialisation:', error);
    res.status(500).json({
      success: false,
      message: 'ErÃ¨ initializasyon'
    });
  }
});

// === ROUTES PROTÃ‰GÃ‰ES ===

// Gestion des agents (accessible par superviseur et propriÃ©taire)
app.get('/api/agents', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const agents = await Agent.find({}, 'agentId agentName funds isActive createdAt')
      .sort({ createdAt: -1 });
    
    res.json({
      success: true,
      agents: agents
    });
  } catch (error) {
    console.error('Erreur rÃ©cupÃ©ration agents:', error);
    res.status(500).json({
      success: false,
      message: 'ErÃ¨ rÃ©cupÃ©ration ajan yo'
    });
  }
});

// CrÃ©er un nouvel agent
app.post('/api/agents', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { agentId, agentName, initialFunds } = req.body;
    
    // VÃ©rifier si l'agent existe dÃ©jÃ 
    const existingAgent = await Agent.findOne({ agentId: agentId.toUpperCase() });
    if (existingAgent) {
      return res.status(400).json({
        success: false,
        message: 'KÃ²d ajan sa deja egziste'
      });
    }

    // Hasher le mot de passe par dÃ©faut
    const hashedPassword = await bcrypt.hash('123456', 10);
    
    const agent = new Agent({
      agentId: agentId.toUpperCase(),
      agentName: agentName,
      password: hashedPassword,
      role: 'agent',
      funds: initialFunds || 10000,
      isActive: true
    });
    
    await agent.save();
    
    res.json({
      success: true,
      message: 'Ajan kreye avÃ¨k siksÃ¨',
      agent: {
        agentId: agent.agentId,
        agentName: agent.agentName,
        funds: agent.funds
      }
    });
  } catch (error) {
    console.error('Erreur crÃ©ation agent:', error);
    res.status(500).json({
      success: false,
      message: 'ErÃ¨ kreye ajan'
    });
  }
});

// Mettre Ã  jour les fonds d'un agent
app.post('/api/agents/:agentId/funds', authenticate, requireRole(['supervisor', 'owner']), async (req, res) => {
  try {
    const { agentId } = req.params;
    const { amount, type } = req.body;
    
    const agent = await Agent.findOne({ agentId: agentId });
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Ajan pa jwenn'
      });
    }
    
    let newBalance;
    if (type === 'add') {
      newBalance = agent.funds + amount;
    } else if (type === 'subtract') {
      newBalance = agent.funds - amount;
    } else {
      return res.status(400).json({
        success: false,
        message: 'Tip operasyon pa valab'
      });
    }
    
    agent.funds = newBalance;
    await agent.save();
    
    res.json({
      success: true,
      message: 'Fonds ajan mete ajou',
      newBalance: newBalance
    });
  } catch (error) {
    console.error('Erreur mise Ã  jour fonds agent:', error);
    res.status(500).json({
      success: false,
      message: 'ErÃ¨ mete ajou fonds'
    });
  }
});

// === ROUTES EXISTANTES (conservÃ©es) ===

// Sauvegarder un ticket
app.post('/api/tickets/save', authenticate, requireRole(['agent']), async (req, res) => {
  try {
    const ticketData = req.body;
    
    // GÃ©nÃ©rer un ID de ticket unique
    const ticketId = `T${Date.now()}${Math.floor(Math.random() * 1000)}`;
    
    const ticket = new Ticket({
      ...ticketData,
      ticketId: ticketId,
      date: new Date()
    });
    
    await ticket.save();
    
    // Mettre Ã  jour les fonds de l'agent (dÃ©duire le total)
    await Agent.findOneAndUpdate(
      { agentId: ticketData.agentId },
      { $inc: { funds: -ticketData.total } }
    );
    
    res.status(201).json({
      success: true,
      message: 'Ticket sauvegardÃ© avec succÃ¨s',
      ticket: ticket
    });
  } catch (error) {
    console.error('Erreur sauvegarde ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la sauvegarde du ticket'
    });
  }
});

// RÃ©cupÃ©rer les tickets d'un agent
app.get('/api/tickets', authenticate, async (req, res) => {
  try {
    const { agentId } = req.query;
    
    // VÃ©rifier les permissions
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen aksÃ¨ a istorik ajan sa a'
      });
    }
    
    const tickets = await Ticket.find({ agentId: agentId })
      .sort({ date: -1 })
      .limit(100);
    
    res.json({
      success: true,
      tickets: tickets
    });
  } catch (error) {
    console.error('Erreur rÃ©cupÃ©ration tickets:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la rÃ©cupÃ©ration des tickets'
    });
  }
});

// RÃ©cupÃ©rer les rapports d'un agent
app.get('/api/reports', authenticate, async (req, res) => {
  try {
    const { agentId } = req.query;
    
    // VÃ©rifier les permissions
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen aksÃ¨ a rapÃ² ajan sa a'
      });
    }
    
    // RÃ©cupÃ©rer tous les tickets de l'agent
    const tickets = await Ticket.find({ agentId: agentId });
    
    // Calculer les totaux
    const totalTickets = tickets.length;
    const totalBets = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
    
    // Calculer les gains (Ã  partir des tickets vÃ©rifiÃ©s)
    const checkedTickets = tickets.filter(t => t.checked);
    const totalWins = checkedTickets.reduce((sum, ticket) => {
      const ticketGains = ticket.bets.reduce((betSum, bet) => betSum + (bet.gain || 0), 0);
      return sum + ticketGains;
    }, 0);
    
    // Calculer les pertes (total des paris - gains)
    const totalLoss = totalBets - totalWins;
    const balance = totalWins - totalLoss;
    
    // Breakdown par jeu
    const gameBreakdown = {};
    tickets.forEach(ticket => {
      ticket.bets.forEach(bet => {
        const game = bet.game;
        if (!gameBreakdown[game]) {
          gameBreakdown[game] = { count: 0, amount: 0 };
        }
        gameBreakdown[game].count += 1;
        gameBreakdown[game].amount += bet.amount;
      });
    });
    
    res.json({
      success: true,
      totalTickets: totalTickets,
      totalBets: totalBets,
      totalWins: totalWins,
      totalLoss: totalLoss,
      balance: balance,
      breakdown: gameBreakdown
    });
  } catch (error) {
    console.error('Erreur rÃ©cupÃ©ration rapports:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la rÃ©cupÃ©ration des rapports'
    });
  }
});

// RÃ©cupÃ©rer les gagnants
app.get('/api/winners', authenticate, async (req, res) => {
  try {
    const { agentId } = req.query;
    
    // VÃ©rifier les permissions
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa gen aksÃ¨ a ganyen ajan sa a'
      });
    }
    
    const winners = await Winner.find({ agentId: agentId })
      .sort({ date: -1 })
      .limit(50);
    
    res.json({
      success: true,
      winners: winners
    });
  } catch (error) {
    console.error('Erreur rÃ©cupÃ©ration gagnants:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la rÃ©cupÃ©ration des gagnants'
    });
  }
});

// Sauvegarder les gagnants
app.post('/api/winners/save', authenticate, requireRole(['agent']), async (req, res) => {
  try {
    const winnerData = req.body;
    
    // VÃ©rifier si le gagnant existe dÃ©jÃ 
    const existingWinner = await Winner.findOne({
      ticketId: winnerData.ticketId,
      drawId: winnerData.drawId
    });
    
    let winner;
    if (existingWinner) {
      winner = await Winner.findOneAndUpdate(
        { _id: existingWinner._id },
        winnerData,
        { new: true }
      );
    } else {
      winner = new Winner(winnerData);
      await winner.save();
    }
    
    res.json({
      success: true,
      message: 'Gagnant sauvegardÃ© avec succÃ¨s',
      winner: winner
    });
  } catch (error) {
    console.error('Erreur sauvegarde gagnant:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la sauvegarde du gagnant'
    });
  }
});

// Mettre Ã  jour les fonds d'un agent
app.post('/api/agent/funds', authenticate, requireRole(['agent']), async (req, res) => {
  try {
    const { agentId, amount, type } = req.body;
    
    // VÃ©rifier que l'agent ne modifie que ses propres fonds
    if (req.user.role === 'agent' && req.user.agentId !== agentId) {
      return res.status(403).json({
        success: false,
        message: 'Ou pa ka modifye fonds ajan sa a'
      });
    }
    
    const agent = await Agent.findOne({ agentId: agentId });
    if (!agent) {
      return res.status(404).json({
        success: false,
        message: 'Agent non trouvÃ©'
      });
    }
    
    let newBalance;
    if (type === 'add') {
      newBalance = agent.funds + amount;
    } else if (type === 'subtract') {
      newBalance = agent.funds - amount;
    } else {
      return res.status(400).json({
        success: false,
        message: 'Type d\'opÃ©ration invalide'
      });
    }
    
    agent.funds = newBalance;
    await agent.save();
    
    res.json({
      success: true,
      message: 'Fonds mis Ã  jour avec succÃ¨s',
      newBalance: newBalance
    });
  } catch (error) {
    console.error('Erreur mise Ã  jour fonds:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise Ã  jour des fonds'
    });
  }
});

// VÃ©rifier le statut des tirages
app.get('/api/draws/status', async (req, res) => {
  try {
    const draws = [
      { id: 'mia_matin', name: 'Miami Matin', time: '13:30', blocked: false },
      { id: 'mia_soir', name: 'Miami Soir', time: '21:50', blocked: false },
      { id: 'ny_matin', name: 'New York Matin', time: '14:30', blocked: false },
      { id: 'ny_soir', name: 'New York Soir', time: '20:00', blocked: false },
      { id: 'ga_matin', name: 'Georgia Matin', time: '12:30', blocked: false },
      { id: 'ga_soir', name: 'Georgia Soir', time: '19:00', blocked: false },
      { id: 'tx_matin', name: 'Texas Matin', time: '11:30', blocked: false },
      { id: 'tx_soir', name: 'Texas Soir', time: '18:30', blocked: false },
      { id: 'tn_matin', name: 'Tunisia Matin', time: '10:00', blocked: false },
      { id: 'tn_soir', name: 'Tunisia Soir', time: '17:00', blocked: false }
    ];
    
    // VÃ©rifier si un tirage est bloquÃ© (3 minutes avant l'heure)
    const now = new Date();
    draws.forEach(draw => {
      const [hours, minutes] = draw.time.split(':').map(Number);
      const drawTime = new Date();
      drawTime.setHours(hours, minutes, 0, 0);
      
      const blockedTime = new Date(drawTime.getTime() - (3 * 60 * 1000));
      draw.blocked = now >= blockedTime && now < drawTime;
    });
    
    res.json({
      success: true,
      draws: draws,
      serverTime: now.toISOString()
    });
  } catch (error) {
    console.error('Erreur statut tirages:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la vÃ©rification du statut des tirages'
    });
  }
});

// Route de test
app.get('/', (req, res) => {
  res.sendFile(__dirname + '/index.html');
});

// Routes pour les pages protÃ©gÃ©es
app.get('/agent1.html', (req, res) => {
  res.sendFile(__dirname + '/agent1.html');
});

app.get('/supervisor.html', (req, res) => {
  res.sendFile(__dirname + '/supervisor.html');
});

app.get('/owner.html', (req, res) => {
  res.sendFile(__dirname + '/owner.html');
});

// DÃ©marrer le serveur
app.listen(PORT, () => {
  console.log(`ğŸš€ Serveur dÃ©marrÃ© sur le port ${PORT}`);
  console.log(`ğŸ“¡ API disponible Ã  http://localhost:${PORT}`);
  console.log(`ğŸ” Page de connexion: http://localhost:${PORT}/`);
  console.log(`ğŸ‘¤ Comptes par dÃ©faut:`);
  console.log(`   - Agent: AGENT01 / 123456`);
  console.log(`   - Superviseur: supervisor / 123456`);
  console.log(`   - PropriÃ©taire: owner / 123456`);
});